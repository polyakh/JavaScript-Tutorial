Что такое асинхронность, это два независимых потока, котрые не отчет в двух процессах не совпадает он разный, э нас должна быть синхронизация
Где у нас присутвует асинхронность
Пользовательские сценарии
 – реакция на действия пользователя и обратная связь
 – валидация форм
 – открытие/закрытие окон
 – работа с клавиатуры
Работа с сетью
Отложенное выполнение кода — таймеры, таймауты

*Глобальный объект Event*

В целях сохранения обратной совместимости, в браузеры (не во все) добавлен объект event, который виден глобально, т.е.
им можно пользоваться на любом уровне приложения/
В объект event записывается событие, которое обрабатывается прямо сейчас.
Существует привычка именовать параметр обработчика
события event, но это неявное зеркалирование, поэтому использование такого названия для параметров обработчиков плохая практика, более приемлемый вариант
названия объекта — evt(лучше именовать его подругому(в качетве параметра))


Нет желания работать, когда работа на постоянной основе должна быть сделано на вчера

Как называть хандлеры: button(currentObject)TypeEventHandler
 
target - описывает тот элемент на котором произошло событие
currentTarget - описывает тот элимент на котором событие было обработано
У каждого события есть свойтво path(оно всегда приобпределено)

Делегирование например мы повесли обраблотчки на document, нажали на ссылку, событе не будут обрботываться на ссылке или кнопке,
оно всплывет до документа, и через event.target мы можем понять на каком элименте произошел кклие
Делегирование, когда мы в обработчеке всетаки идет проверка элимента на который кликнули по
если условие кроме на какую клавишу мы нажали уже пролетели мимо делигирования


stopPropogation - прекращает ту фазу в которой событие сейчас находиться, если это сплытие или захват 
stopPropogation нужно быть осторожным с делегированиемЮ нужно чувтвовать грань, когда ког фнтри обрабочикса сложный, нас не подходит делегирование

document.body.appendChild(el);
document.addEventListener('keydown', function () {
if (evt.keyCode ""=== 27) {
document.body.removeChild(el);
}
});
обработчик использует внешние значения,
привязан не на элемент вместе с которым
создан или содержит асинхронную логику
элемент в данный момент не виден

parentNode.innerHTML = '';
обработчик использует только DOM-
объект на котором он был создан, в нем
нет асинхронной логики и утечек (след.
лекция)