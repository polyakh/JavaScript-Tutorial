JS - не умеет работать с HTML, он не может работать с тегами с атрибутами, с текстами которые лежат внутри него, единственно с чем JS
умеет работать это строка это очень не удобно. Мы разбиваем все теги на объекты, каждому тегу мы создаем объект который будет описывать этот тег.
DOM - дерево описывает всю разметку которая у нас есть, это пробелы переносы строк табуляции, комментарии, это работает внутри других тегов h1, h2,
псевдоэлементы не являются частью DOM(они виртуальные, на них нет ссылки).
DOM представляет документ как иерархическое дерево узлов, позволяя добавлять, удалять и изменять отдельные части страницы.

### Иерархия узлов 
HTML можно представить с помощью DOM как иерархию узлов, узлы бываю разных типов, которые соответствуют разным элементам разметки в документе.
Каждый тип узлов обладает определенными характеристиками: данными, методами и может быть связан с другими узлами.
Скриншот 1
Обычно html называют элементом документа - это самый внешний элемент в документе, котрый содержит все отсальные элименты.
В документе может быть только один элемент документа, всем элементам разметки соответствуют узлы в дереве: HTML -элементам - узлы элиментов и так дал


Что из себя предоставляет дерево?
 – узел — любой элемент дерева;
 – родитель — элемент, из которого растет узел;
 – дети — элементы, которые растут из узла;
 – корень — элемент из которого растет дерево, элемент без родителей;
 – лист — элемент дерева, который не имеет детей;
 - дерево может иметь только один корень;
 - у каждого элемента должно быть не более одного родителя.

Какой бы вы выбрали корневой элемент DOM дерева ?
Корневой элемент DOM - это document, document(описывает открытую в браузере страницу) это элемент, который объединяет другие элементы 

### Поиск DOM-элементов
 – ручной обход дерева, начиная с корневого элемента(children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling)
 – поиск по ID, тегу или названию класса
 – поиск по CSS-селектору (querySelector/querySelectorAll) использует DFS, работает с CSS - селекторами(селекторы сосотяния, кроме псевдоэлиментов)
Поиск в глубину по дереву, если у узла есть потомки он спускается сначала к ним.
Поиск в ширину, потомков переберем после того как перебрали родителей.
Поиск элементов на страницу осуществляется поиском элементов в глубину(), если мы хотим найти ссылку JS будет искать в глубину.
Если мы хотим отрендерить страницу JS будет искать в ширину, зачем чтобы ничего не прыгало от крупных к меньшим.+
Каждый элемент который есть в дереве содержит ссылки, во-первых, все дом элементы ссылаются на своих родителей во вторых на своих потомков

У document есть свойство all - содержит все элементы которые есть на странице плоская структура, по id+++, он быстрее чем querySelector поскольку храниться в отдельном свойтве, document

```javascript
document.querySelectorAll(""); // будет искать в глубину, мы будем добавлять в коллекцию элементы в порядке их нахождения, даже если второй
// находиться гораздо выше. Будет найден начала возможно само глубока расположенный элемент, потом возможно гораздо выше по дереву
```
https://learn.javascript.ru/dom-attributes-and-properties
Вообще говоря, браузер не гарантирует синхронизацию атрибута и свойства.

Не очень хорошо работать с элементами как с разметкой, setAttr, getAttr, это работа не с DOM api(api - это набор свойтв и методов чем либо)

!Что важно например если мы сохраняем колекцию в переменную, на нее есть ссылка, и удаляем элемент с DOM, из любых узлов дерева на него больше нет ссылки ссылка остаться в колекции
```javascript
    document.querySelectorAll(""); // это коллекция которая хранит состаяние на момент выз+ова querySelectorAll
    function delElement() {
       const collection = document.querySelectorAll("");
       const child = document.querySelector(".div-1");
       collection[0].removeChild(child); 
    } // функция отработала, больше ссылки нет в DOM на элемент, у нас нет возможности его получить 
```

!!У несколько методов поиска элиментов DOM - при использовании встроенного API, который  поддерживает несколько вариантов использования, используем один способ,
что это значит, если мы получаем элименты с помощью querySelector, использем только его без всяких getEkementById

```javascript
    document.querySelector("div").classList.add()
```


1. Изменение DOM !== Изменение разметки, разметка это initialState, но мы можем, что-то вводить в input radio-buttons переключать, и если
мы работаем с разметкой +есть вероятность, что мы работаем уже не с актуальными состоянием нашего DOM, seAttr - меняет разметку

### Управление DOM-деревом
```javascript
    data1
    data2

    removeChild // метод возвращает удалённый дочерний узел, его можно сохранить к примеру в переменной, чтобы, если необходимо, к нему можно было бы обратиться позднее в коде.
    remove
    // removeнужна только ссылка на ребенка. removeChildнужна ссылка как на родителя, так и на ребенка. Результат идентичен.

    apepend
    insertBefo // (что, перед чем | нет разницы)
    replaceChild // вырезать и сохранить Заменяет дочерний элемент на выбранный. Возвращает замененный элемент.
    cloneNode 
```

### Добавление элиментов на страницу
1. innerHTML - значение строка, которая содердит в себе HTML, элименты, проблема использования, даже если мы хотим заменить один элимен, все дом ноды будет удалены на их место станут новые
```javascript
const heroName = document.querySelector("b");
heroName.textContent = "Random name";
document.body.innerHTML = "<h1>Привет</h1>" + document.body.innerHTML; 
heroName.textContent = "Old name"; // не будет работать, покольку на данный момент в доме другой элемент(b, но он есть в памяти), ссылка не так, мы перезаписали b после того как достали его из DOM
```
2.


3.documnet.body.insertAjacentHTML(""") добавить разметку точечно, afterbegin - после откр тега, beforebegin - перд откт тегом,
afterend - ставка чего-то после хакр тега beforeend - вставка перед закрыв тегом.
!Это удобно без полных перерисовок DOM, но у нас нет возомжноти добавить что-то в середину, опасно всталять что-то через innerHTML, важно только через textContent, когда можем это использовать когда это просто голый каркас
```javascript

```
.4 createElement - с помощью DOM, api, вернет нам новую node кторая не будет вставлена на страницу

##Tamplate 
Содержимое шаблона доступно по его свойству content в качестве DocumentFragment 
template
documentFragment содержит в себе другие элементы, ну него нет представления


Шаблон и данные
- шаблон - это оболочка для данных, разметка способ отобразить информацию
- данные - информация, которую вводить пользователь присылает сервер, котрая генерируется компьютером

Шаблон и данные
Данные не должны повторять шаблон, данные должны описывать сущности, которыми мы оперируем. Простой способ отделить шаблон 
от данных — попробовать заменить их: поменять способ отображения или отображаемую информацию
Шаблоны нужно клонировать поскольу будет, ссылка на один итоже шаблон
