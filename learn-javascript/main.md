###Термины: «унарный-оператор», «бинарный-оператор», «операнд»
Операнд – то, к чему применяется оператор: 5 * 2.
!Все операторы возвращают значение.
Унарным называется оператор, который применяется к одному операнду. "-" меняет знак числа на противоположный:
```javascript
let x = 1; x = -x; console.log(x); // -1, применили унарный минус.
```
Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:
```javascript
let x = 1, y = 3; console.log(y - x); // 2, бинарный минус
```


###Преобразование типов
Их всегда 3
**Строковое**:
```javascript
alert();
String(value);
"string" + value;
``` 
**Численное**, осуществляется не явным образом математическими функциями и операторами, кроме сложения со строкой:
```javascript
"1" + 0 / 100
"1" - 0 // минус не умеет работать строками и преобразовал к числу 
```
унарные оператор +
```javascript
+"123" // хотим сложить значения как числа
+"1" + +"0"
// если это переменные 
+a + +b
```
Значение типа undefined null, как правило, когда мы приводим значение к числу, то подразумевается, что значение интуитивно близки к 0, в которых по замыслу ничего не содержится должны становится 0
```javascript
+"0" // 0
+false // 0
+null // 0
// исключение это 
undefined / NaN
+true / 1
```
Строки преобразуются считывание числа, пробелы игнорируем \n как и символы перевода строк потом считали число -12.345 конечные пробелы тоже игнорируем, если где-то не пробельные символы будет NaN/
корректно преобразуем строки, которые есть научной записью +”2e5”, или 16ти ричные  +”0xff”
```javascript
true > false // true
true - false / 1 // 1
true + NaN / NaN? true // к числу, но сложение с NaN дает NaN
```
К числу преобразует математические функции, операторы, кроме сложения со стройкой к числу преобразуют сравнения, кроме сравнения двух строк, которые сравниваем лексикографически “Вася” > “Вася”, 
в том числе, если оператор == применятся к значению разных типов, есть важные момент, с null and undefined, null == undefined / true но эти значения не равны ни какому другому, при сравнение null undefined сравнения нет, всё прочие знач, при == преобразуются 
“1” == true приведение к числу, и то и другое станет единицей.

**Логическое**
оно используется для проверки условий if а также в конструкциях конструкций while for и так дал?
кроме того логические преобразования в операторах логическое ! && ||, эти операторы использует логическое преобразование чтобы получить результат но возвращают они не логическое  значение, 
а то которое анализировали последним, то которое определил результат, те знач. которые интуитивно ничего не содержат false остальные true?
```javascript
Boolean(0); // false
Boolean(NaN); // false
null if(null); // false преобразовали к false, все числа true кроме 0 NaN
```
строки всё true кроме пустой строки, “0“, true object array, двойное отрицание, первое отрицание преобразует люб значение к логическому и возвращает обратное, а второе обращает его еще раз !![]
Преобразование к строке alert делает неявное преобразование
"" + null // "null" если один аргумент строка, второй будет приведен к строке


###Инкремент/декремент
Инкремент ++ увеличивает на 1 Декремент -- уменьшает на 1. !Инкремент/декремент можно применить только к переменной.
Операторы counter++ это «постфиксная форма», и ++counter «Префиксная форма».
Если результат оператора не используется, а нужно только увеличить/уменьшить переменную – без разницы, какую форму использовать.
```javascript
let i = 0
let result = i++;
result // 0 результат оператора, хотя само значение i уже = 1, result это результат i++
```
###Логические операторы

**&&** первое ложное, ложных нет последнее
```javascript
true  && true      // t && t вернёт true
true  && false     // t && f вернёт false
false && true      // f && t вернёт false
false && (3 === 4)  // f && f вернёт false
"Cat" && "Dog"     // t && t вернёт "Dog"
false && "Cat"     // f && t вернёт false
"Cat" && false     // t && f вернёт false
```
**||** первое истинное(по коду юникод идут большие потом маленькие буквы).
```javascript
true  || true       // t || t вернёт true
false || true       // f || t вернёт true
true  || false      // t || f вернёт true
false || (3 === 4)   // f || f вернёт false
"Cat" || "Dog"      // t || t вернёт "Cat"
false || "Cat"      // f || t вернёт "Cat"
"Cat" || false      // t || f вернёт "Cat"
```

*!this объект перед точкой*
Функции объекты, не имеет отношения к переменным внутри функции, переменных внутри функции не доступны.
```javascript
let a = {}; let b = a // true
```


###Лексическое окружение
Лексическое окружение, глобальный, локальный, переменные, существует до момента входа в блок декларация, функция переменную ищет у себя, 
потом снаружи.
```javascript
let a = 5 // свойства спец скрытого специального объекта, во время вып. функции он создал , после удаляется  
const a = ""
{ const b = "" }
b // error, notLV
```
Глобальные объект был глобальным лексикал инвайромент, как бы одно и тоже.
В современном стандарте эти сущности были разделены, и глобальный объект дает доступ к переменным, которые были объявлены как var, и к глобальным функциям/

*Замыкание* - это, функция всегда имеет доступ к внешней переменной, что эта переменная берется на момент запуска, поиск происходит с функций которую запустили 


### Методы
**Метод toFixed()** форматирует число, используя запись с фиксированной запятой.
```javascript
const numObj = 12345.6789;
numObj.toFixed();       // Вернёт '12346': обратите внимание на округление, дробной части нет
numObj.toFixed(1);      // Вернёт '12345.7': обратите внимание на округление
```
**startsWith(searchString[, position])** определяет, начинается ли строка с символов другой строки, возвращая, соответственно, true или false.
```javascript
const str = "Быть или не быть, вот в чём вопрос.";
str.startsWith("Быть"); // true
str.startsWith("не быть"); // false
str.startsWith("не быть", 9); // true
```
**endsWith(searchString[, position])** определяет, заканчивается ли строка символами другой строки, возвращая, соответственно, true или false
```javascript
const str = "Быть или не быть, вот в чём вопрос.";
str.endsWith("вопрос."); // true
str.endsWith("быть"); // false
str.endsWith("быть", 16); // true
```

###Symbol
symbol для скрытых свойств объектов
Reflect.ownKeys() возвращает массив имен, а также Symbols собственных полей объекта target .
```javascript
const object1 = { property1: 42, };
const array1 = [];
Reflect.ownKeys(object1); // expected output: Array ["property1", "property2"]
Reflect.ownKeys(array1); // expected output: Array ["length"]
```

*Поменять местам переменные*:
let a = 1; let b = 2; [b, a] = [a, b];



for of, foreach нельзя прервать, [Symbol.iterator]
Arra.from(nodeList).map
https://prnt.sc/rxgt4l // не рекурсия функция не вызывает себя
[1,2,4].map(console.log)



window[Symbol.toStringTag]

bind // exotic Object нельзя перебиндить, он запомнил
2017-05-22/ 44 мин

*in* возвращает true, если свойство содержится в указанном объекте или в его цепочке прототипов.
```javascript
const mycar = {make: "Honda", model: "Accord", year: 1998};
"make" in mycar  // true

const trees = new Array("redwood", "bay", "cedar", "oak", "maple");
0 in trees // true
```



int32Array // типизированный массив

123^0 // отбросить 10-тичную часть

return в конце конструктора вернут текущий объект если явно написать, и вернуть не объект будет проигнорировано
https://prnt.sc/rzsog9
